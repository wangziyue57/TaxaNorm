weights <- 1
}
if (length(weights) == 1) {
weights <- rep.int(weights, n)
}
weights <- as.vector(weights)
names(weights) <- rownames(mf)
offsetx <- model_offset_2(mf, terms = mtX, offset = TRUE)
if (is.null(offsetx)) {
offsetx <- 0
}
if (length(offsetx) == 1) {
offsetx <- rep.int(offsetx, n)
}
offsetx <- as.vector(offsetx)
offsetm <- model_offset_2(mf, terms = mtM, offset = FALSE)
if (is.null(offsetm)) {
offsetm <- 0
}
if (length(offsetm) == 1) {
offsetm <- rep.int(offsetm, n)
}
offsetm <- as.vector(offsetm)
start <- control$start
if (!is.null(start)) {
valid <- TRUE
if (!("count" %in% names(start))) {
valid <- FALSE
warning("invalid starting values, count model coefficients not specified")
start$count <- rep.int(0, kx)
}
if (!("theta" %in% names(start))) {
valid <- FALSE
warning("invalid starting values, dispersion model coefficients not specified")
start$theta <- rep.int(0, km)
}
if (length(start$count) != kx) {
valid <- FALSE
warning("invalid starting values, wrong number of count model coefficients")
}
if (length(start$theta) != km) {
valid <- FALSE
warning("invalid starting values, wrong number of dispersion coefficients")
}
if (!valid) {
start <- NULL
}
}
if (is.null(start)) {
if (control$trace) {
cat("generating starting values...\n")
}
# offset confusion, to circumvent, we use it as a covariate
# Supply a different starting point
m0 <- MASS::glm.nb(Y ~ 1 + offsetx)
start$count <- c(m0$coefficients[1], rep(0, kx - 1))
start$theta <- c(log(m0$theta), rep(0, km - 1))
}
if (control$trace) {
cat("begin model fitting...\n")
}
mu.ind <- 1 : kx
theta.ind <- (kx + 1) : (kx + km)
paras0 <- c(start$count, start$theta)
nlm.obj <- nlm(loglik0.nb, p=paras0, mu.ind=mu.ind, theta.ind=theta.ind, X.mu=X, X.theta=M, y=Y,
offsetx=offsetx, offsetm=offsetm, hessian=TRUE, ...)
fit <- nlm.obj
paras1 <- nlm.obj$estimate
fit$loglik <- - loglik0.nb(paras1, mu.ind, theta.ind, X, M, Y, offsetx, offsetm)
if (sum(!(fit$code %in% c(1, 2)))) {
warning("optimization failed to converge in some iterations!\n")
fit$converged <- FALSE
} else {
fit$converged <- TRUE
}
if (control$trace) {
if (fit$converged) {
cat("model converged...\n")
} else {
cat("model not converged...\n")
}
}
coefc <- fit$estimate[(1):(kx)]
names(coefc) <- names(start$count) <- colnames(X)
coefm <- fit$estimate[(kx + 1):(kx + km)]
names(coefm) <- names(start$theta) <- colnames(M)
vc <- try(solve(as.matrix(fit$hessian)), silent = TRUE)
if(inherits(vc,"try-error")==FALSE){
colnames(vc) <- rownames(vc) <-
c(paste("count", colnames(X), sep = "."),
paste("dispersion", colnames(M), sep = "."))
}else vc <- matrix(NA, (kx+km), (kx+km))
mu <- exp(X %*% coefc + offsetx)[, 1]
theta <- exp(M %*% coefm + offsetm)[, 1]
coefz <- NA
pi <- rep(0,length(mu))
Yhat <- mu
res <- sqrt(weights) * (Y - Yhat)
nobs <- sum(weights > 0)
rval <- list(coefficients = c(coefc, coefz, coefm),
estimates = list(mu = mu, pi = pi, theta = theta),
residuals = res, fitted.values = Yhat, nlmfit = fit,
control = control, start = start,
weights = if (identical(as.vector(weights), rep.int(1L, n))) NULL else weights,
offset = list(count = if (identical(offsetx,  rep.int(0, n))) NULL else offsetx,
dispersion = if (identical(offsetm, rep.int(0, n))) NULL else offsetm),
n = nobs, df.null = nobs - 2, df.residual = nobs - (kx + km),
terms = list(count = mtX, dispersion = mtM, full = mt),
loglik = fit$loglik,
converged = fit$converged, call = cl, formula = ff,
levels = .getXlevels(mt, mf), contrasts = list(count = attr(X, "contrasts"), dispersion = attr(M, "contrasts")))
if (model) {
rval$model <- mf
}
if (y) {
rval$y <- Y
}
if (x) {
rval$x <- list(count = X, dispersion = M)
}
class(rval) <- "nb.reg"
return(rval)
}
# fit reduced model
# test 1: existence of effect or not; by fitting intercept-only regression
if(prev){
fit_reduce_1 <- list()
for (i in 1:nrow(count)) {
zero <- sum(count[i,]==0)
if(zero >= 10){
if(is.null(group)){
fit_reduce_1[[i]] <- suppressWarnings(suppressWarnings(zinb.reg(formula = count[i,] ~ 1 | 1 | 1,
control = zinb.control(trace=FALSE, EM=TRUE))))
}else{
fit_reduce_1[[i]] <- suppressWarnings(zinb.reg(formula = count[i,] ~ 1 + group | 1 | 1,
control = zinb.control(trace=FALSE)))
}
}
if(zero < 10){
if(is.null(group)){
fit_reduce_1[[i]] <- suppressWarnings(suppressWarnings(nb.reg(formula = count[i,] ~ 1 | 1,
control = zinb.control(trace=FALSE, EM=TRUE))))
}else{
fit_reduce_1[[i]] <- suppressWarnings(suppressWarnings(nb.reg(formula = count[i,] ~ 1 + group | 1,
control = zinb.control(trace=FALSE, EM=TRUE))))
}
}
}
if (any(sapply(fit_reduce_1, inherits, "try-error")==TRUE)) {
fit_reduce_1 <- fit_reduce_1[-which(sapply(fit_reduce_1, inherits, "try-error")==TRUE)]
}
llk.null <- sapply(fit_reduce_1, function(x) x$loglik)
# lrt test
na <- unique(c(which(is.na(llk.full)), which(is.na(llk.null))))
if(length(na) == 0){
llk_H1 <- llk.full
llk_H0 <- llk.null
df_H1 <- res$df
df_H0 <- sapply(fit_reduce_1, function(x) x$df.residual)
}else{
llk_H1 <- llk.full[-na]
llk_H0 <- llk.null[-na]
df_H1 <- df_H1 <- res$df[-na]
df_H0 <- sapply(fit_reduce_1, function(x) x$df.residual)[-na]
}
df <- sum(df_H0) - sum(df_H1)
chi_stat <- 2 * (sum(llk_H1) - sum(llk_H0))
pvalue_1 <- pchisq(chi_stat, df = df, lower.tail = FALSE)
} else {pvalue_1 <- NA}
fit_reduce_1 <- list()
for (i in 1:nrow(count)) {
zero <- sum(count[i,]==0)
if(zero >= 10){
if(is.null(group)){
fit_reduce_1[[i]] <- suppressWarnings(suppressWarnings(zinb.reg(formula = count[i,] ~ 1 | 1 | 1,
control = zinb.control(trace=FALSE, EM=TRUE))))
}else{
fit_reduce_1[[i]] <- suppressWarnings(zinb.reg(formula = count[i,] ~ 1 + group | 1 | 1,
control = zinb.control(trace=FALSE)))
}
}
if(zero < 10){
if(is.null(group)){
fit_reduce_1[[i]] <- suppressWarnings(suppressWarnings(nb.reg(formula = count[i,] ~ 1 | 1,
control = zinb.control(trace=FALSE, EM=TRUE))))
}else{
fit_reduce_1[[i]] <- suppressWarnings(suppressWarnings(nb.reg(formula = count[i,] ~ 1 + group | 1,
control = zinb.control(trace=FALSE, EM=TRUE))))
}
}
}
library(TaxNorm)
library(TaxNorm)
library(TaxNorm)
devtools::document()
warnings()
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(TaxNorm)
library(phyloseq)
library(microbiome)
library(ggplot2)
library(vegan)
library(MASS)
data("TaxNorm_Example_Input", package = "TaxNorm")
#save(Normalized_Data, file = "sample_taxnormresults.RData")
load(file = "sample_taxnormresults.RData")
Normalized_Results = Normalized_Data
prev = TRUE
equiv = TRUE
group = sample_data(TaxNorm_Example_Input)$body_site
# extract info from run_norm() output (full model)
res <- Normalized_Results
count <- rawdata(res)
llk.full <- llk(res)
# fit reduced model
# test 1: existence of effect or not; by fitting intercept-only regression
if(prev){
fit_reduce_1 <- list()
for (i in 1:nrow(count)) {
zero <- sum(count[i,]==0)
if(zero >= 10){
if(is.null(group)){
fit_reduce_1[[i]] <- suppressWarnings(suppressWarnings(zinb.reg(formula = count[i,] ~ 1 | 1 | 1,
control = zinb.control(trace=FALSE, EM=TRUE))))
}else{
fit_reduce_1[[i]] <- suppressWarnings(zinb.reg(formula = count[i,] ~ 1 + group | 1 | 1,
control = zinb.control(trace=FALSE)))
}
}
if(zero < 10){
if(is.null(group)){
fit_reduce_1[[i]] <- suppressWarnings(suppressWarnings(nb.reg(formula = count[i,] ~ 1 | 1,
control = zinb.control(trace=FALSE, EM=TRUE))))
}else{
fit_reduce_1[[i]] <- suppressWarnings(suppressWarnings(nb.reg(formula = count[i,] ~ 1 + group | 1,
control = zinb.control(trace=FALSE, EM=TRUE))))
}
}
}
if (any(sapply(fit_reduce_1, inherits, "try-error")==TRUE)) {
fit_reduce_1 <- fit_reduce_1[-which(sapply(fit_reduce_1, inherits, "try-error")==TRUE)]
}
llk.null <- sapply(fit_reduce_1, function(x) x$loglik)
# lrt test
na <- unique(c(which(is.na(llk.full)), which(is.na(llk.null))))
if(length(na) == 0){
llk_H1 <- llk.full
llk_H0 <- llk.null
df_H1 <- res$df
df_H0 <- sapply(fit_reduce_1, function(x) x$df.residual)
}else{
llk_H1 <- llk.full[-na]
llk_H0 <- llk.null[-na]
df_H1 <- df_H1 <- res$df[-na]
df_H0 <- sapply(fit_reduce_1, function(x) x$df.residual)[-na]
}
df <- sum(df_H0) - sum(df_H1)
chi_stat <- 2 * (sum(llk_H1) - sum(llk_H0))
pvalue_1 <- pchisq(chi_stat, df = df, lower.tail = FALSE)
} else {pvalue_1 <- NA}
count[1,]
count[i,] ~ 1 + group | 1 | 1
count[1,]
fit_reduce_1[[i]] <- suppressWarnings(zinb.reg(formula = count[i,] ~ 1 + group | 1 | 1,
control = zinb.control(trace=FALSE)))
View(count)
typeof(count[1,])
count[1,]
View(count)
typeof(count[1])
typeof(count[2])
count[1,]
as.numeric(count[1,])
fit_reduce_1 <- list()
for (i in 1:nrow(count)) {
zero <- sum(count[i,]==0)
if(zero >= 10){
if(is.null(group)){
fit_reduce_1[[i]] <- suppressWarnings(suppressWarnings(zinb.reg(formula = as.numeric(count[i,]) ~ 1 | 1 | 1,
control = zinb.control(trace=FALSE, EM=TRUE))))
}else{
fit_reduce_1[[i]] <- suppressWarnings(zinb.reg(formula = as.numeric(count[i,]) ~ 1 + group | 1 | 1,
control = zinb.control(trace=FALSE)))
}
}
if(zero < 10){
if(is.null(group)){
fit_reduce_1[[i]] <- suppressWarnings(suppressWarnings(nb.reg(formula = as.numeric(count[i,]) ~ 1 | 1,
control = zinb.control(trace=FALSE, EM=TRUE))))
}else{
fit_reduce_1[[i]] <- suppressWarnings(suppressWarnings(nb.reg(formula = as.numeric(count[i,]) ~ 1 + group | 1,
control = zinb.control(trace=FALSE, EM=TRUE))))
}
}
}
if (any(sapply(fit_reduce_1, inherits, "try-error")==TRUE)) {
fit_reduce_1 <- fit_reduce_1[-which(sapply(fit_reduce_1, inherits, "try-error")==TRUE)]
}
llk.null <- sapply(fit_reduce_1, function(x) x$loglik)
# lrt test
na <- unique(c(which(is.na(llk.full)), which(is.na(llk.null))))
if(length(na) == 0){
llk_H1 <- llk.full
llk_H0 <- llk.null
df_H1 <- res$df
df_H0 <- sapply(fit_reduce_1, function(x) x$df.residual)
}else{
llk_H1 <- llk.full[-na]
llk_H0 <- llk.null[-na]
df_H1 <- df_H1 <- res$df[-na]
df_H0 <- sapply(fit_reduce_1, function(x) x$df.residual)[-na]
}
df <- sum(df_H0) - sum(df_H1)
chi_stat <- 2 * (sum(llk_H1) - sum(llk_H0))
devtools::document()
devtools::document()
devtools::document()
devtools::document()
library(TaxNorm)
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(TaxNorm)
library(phyloseq)
library(microbiome)
library(ggplot2)
library(vegan)
library(MASS)
data("TaxNorm_Example_Input", package = "TaxNorm")
library(TaxNorm)
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(TaxNorm)
library(phyloseq)
library(microbiome)
library(ggplot2)
library(vegan)
library(MASS)
data("TaxNorm_Example_Input", package = "TaxNorm")
# run normalization
Normalized_Data <- TaxNorm_Normalization(data= TaxNorm_Example_Input,
depth = NULL,
group = sample_data(TaxNorm_Example_Input)$body_site,
meta.data = NULL,
filter.cell.num = 10,
filter.taxa.count = 0,
random = FALSE,
ncores = NULL)
save(Normalized_Data, file = "sample_taxnormresults.RData")
Normalized_Results = Normalized_Data
# extract info from run_norm() output (full model)
res <- Normalized_Results
count <- rawdata(res)
llk.full <- llk(res)
# fit reduced model
# test 1: existence of effect or not; by fitting intercept-only regression
if(prev){
fit_reduce_1 <- list()
for (i in 1:nrow(count)) {
zero <- sum(count[i,]==0)
if(zero >= 10){
if(is.null(group)){
fit_reduce_1[[i]] <- suppressWarnings(suppressWarnings(zinb.reg(formula = as.numeric(count[i,]) ~ 1 | 1 | 1,
control = zinb.control(trace=FALSE, EM=TRUE))))
}else{
fit_reduce_1[[i]] <- suppressWarnings(zinb.reg(formula = as.numeric(count[i,]) ~ 1 + group | 1 | 1,
control = zinb.control(trace=FALSE)))
}
}
if(zero < 10){
if(is.null(group)){
fit_reduce_1[[i]] <- suppressWarnings(suppressWarnings(nb.reg(formula = as.numeric(count[i,]) ~ 1 | 1,
control = zinb.control(trace=FALSE, EM=TRUE))))
}else{
fit_reduce_1[[i]] <- suppressWarnings(suppressWarnings(nb.reg(formula = as.numeric(count[i,]) ~ 1 + group | 1,
control = zinb.control(trace=FALSE, EM=TRUE))))
}
}
}
if (any(sapply(fit_reduce_1, inherits, "try-error")==TRUE)) {
fit_reduce_1 <- fit_reduce_1[-which(sapply(fit_reduce_1, inherits, "try-error")==TRUE)]
}
llk.null <- sapply(fit_reduce_1, function(x) x$loglik)
# lrt test
na <- unique(c(which(is.na(llk.full)), which(is.na(llk.null))))
if(length(na) == 0){
llk_H1 <- llk.full
llk_H0 <- llk.null
df_H1 <- res$df
df_H0 <- sapply(fit_reduce_1, function(x) x$df.residual)
}else{
llk_H1 <- llk.full[-na]
llk_H0 <- llk.null[-na]
df_H1 <- df_H1 <- res$df[-na]
df_H0 <- sapply(fit_reduce_1, function(x) x$df.residual)[-na]
}
df <- sum(df_H0) - sum(df_H1)
chi_stat <- 2 * (sum(llk_H1) - sum(llk_H0))
pvalue_1 <- pchisq(chi_stat, df = df, lower.tail = FALSE)
} else {pvalue_1 <- NA}
# test 2: equivalence of effect or not; by fitting offset() term
if(equiv){
fit_reduce_2 <- list()
for (i in 1:nrow(count)) {
zero <- sum(count[i,]==0)
if(zero >= 10){
if(is.null(group)){
fit_reduce_2[[i]] <- suppressWarnings(suppressWarnings(zinb.reg(formula = count[i,] ~ offset(log(depth)) | 1 | 1,
control = zinb.control(trace=FALSE, EM=TRUE))))
}else{
fit_reduce_2[[i]] <- suppressWarnings(zinb.reg(formula = count[i,] ~ offset(log(depth)) + group | 1 | 1,
control = zinb.control(trace=FALSE)))
}
}
if(zero < 10){
if(is.null(group)){
fit_reduce_2[[i]] <- suppressWarnings(suppressWarnings(nb.reg(formula = count[i,] ~ offset(log(depth)) | 1,
control = zinb.control(trace=FALSE, EM=TRUE))))
}else{
fit_reduce_2[[i]] <- suppressWarnings(suppressWarnings(nb.reg(formula = count[i,] ~ offset(log(depth)) + group | 1,
control = zinb.control(trace=FALSE, EM=TRUE))))
}
}
}
if (any(sapply(fit_reduce_2, inherits, "try-error")==TRUE)) {
fit_reduce_2 <- fit_reduce_2[-which(sapply(fit_reduce_2, inherits, "try-error")==TRUE)]
}
llk.null <- sapply(fit_reduce_2, function(x) x$loglik)
# lrt test
na <- unique(c(which(is.na(llk.full)), which(is.na(llk.null))))
if(length(na) == 0){
llk_H1 <- llk.full
llk_H0 <- llk.null
df_H1 <- res$df
df_H0 <- sapply(fit_reduce_2, function(x) x$df.residual)
}else{
llk_H1 <- llk.full[-na]
llk_H0 <- llk.null[-na]
df_H1 <- df_H1 <- res$df[-na]
df_H0 <- sapply(fit_reduce_2, function(x) x$df.residual)[-na]
}
df <- sum(df_H0) - sum(df_H1)
chi_stat <- 2 * (sum(llk_H1) - sum(llk_H0))
pvalue_2 <- pchisq(chi_stat, df = df, lower.tail = FALSE)
}else {pvalue_2 <- NA}
prev = TRUE
equiv = TRUE
group = sample_data(TaxNorm_Example_Input)$body_site
# fit reduced model
# test 1: existence of effect or not; by fitting intercept-only regression
if(prev){
fit_reduce_1 <- list()
for (i in 1:nrow(count)) {
zero <- sum(count[i,]==0)
if(zero >= 10){
if(is.null(group)){
fit_reduce_1[[i]] <- suppressWarnings(suppressWarnings(zinb.reg(formula = as.numeric(count[i,]) ~ 1 | 1 | 1,
control = zinb.control(trace=FALSE, EM=TRUE))))
}else{
fit_reduce_1[[i]] <- suppressWarnings(zinb.reg(formula = as.numeric(count[i,]) ~ 1 + group | 1 | 1,
control = zinb.control(trace=FALSE)))
}
}
if(zero < 10){
if(is.null(group)){
fit_reduce_1[[i]] <- suppressWarnings(suppressWarnings(nb.reg(formula = as.numeric(count[i,]) ~ 1 | 1,
control = zinb.control(trace=FALSE, EM=TRUE))))
}else{
fit_reduce_1[[i]] <- suppressWarnings(suppressWarnings(nb.reg(formula = as.numeric(count[i,]) ~ 1 + group | 1,
control = zinb.control(trace=FALSE, EM=TRUE))))
}
}
}
if (any(sapply(fit_reduce_1, inherits, "try-error")==TRUE)) {
fit_reduce_1 <- fit_reduce_1[-which(sapply(fit_reduce_1, inherits, "try-error")==TRUE)]
}
llk.null <- sapply(fit_reduce_1, function(x) x$loglik)
# lrt test
na <- unique(c(which(is.na(llk.full)), which(is.na(llk.null))))
if(length(na) == 0){
llk_H1 <- llk.full
llk_H0 <- llk.null
df_H1 <- res$df
df_H0 <- sapply(fit_reduce_1, function(x) x$df.residual)
}else{
llk_H1 <- llk.full[-na]
llk_H0 <- llk.null[-na]
df_H1 <- df_H1 <- res$df[-na]
df_H0 <- sapply(fit_reduce_1, function(x) x$df.residual)[-na]
}
df <- sum(df_H0) - sum(df_H1)
chi_stat <- 2 * (sum(llk_H1) - sum(llk_H0))
pvalue_1 <- pchisq(chi_stat, df = df, lower.tail = FALSE)
} else {pvalue_1 <- NA}
df_H1 <- final_df(res)
df_H1 <- df_H1 <- final_df(res)[-na]
# lrt test
na <- unique(c(which(is.na(llk.full)), which(is.na(llk.null))))
library(TaxNorm)
library(TaxNorm)
devtools::document()
devtools::document()
devtools::document()
getNamespaceExports("TaxaNorm")
getNamespaceExports("TaxNorm")
roxygen2::roxygenise()
